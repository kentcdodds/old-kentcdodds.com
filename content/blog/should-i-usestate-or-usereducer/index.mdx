---
slug: should-i-usestate-or-usereducer
date: 2020-03-09
title: 'Should I useState or useReducer?'
author: 'Kent C. Dodds'
description:
  Two built-in React hooks that handle state, which one should you use?
categories: ['react']
keywords: ['react', 'javascript', 'hooks']
banner: './banner.png'
bannerCredit:
  Photo by [Kyle Glenn](https://unsplash.com/photos/IFLgWYlT2fI) on
  [Unsplash](https://unsplash.com/search/photos/uncertain)
---

Whenever there are two things to do the same thing, people inevitably ask: "When
do I use one over the other?" There are two possible reasons for having multiple
ways of doing the same thing:

1. One is the "old way" and the other is the "new (and improved) way". Typically
   the old way is kept around for backward compatibility reasons and the new way
   is the path forward for new code. For example: class components (old way) vs
   function components (new way).
2. They come with different trade-offs that should be considered and therefore
   should be applied in situations that suit them better (sometimes meaning
   you'll use more than one in a given application). For example:
   [`useEffect` vs `useLayoutEffect`](/blog/useeffect-vs-uselayouteffect) or
   [Static vs Unit vs Integration vs E2E tests](/blog/unit-vs-integration-vs-e2e-tests)
   or
   ["Control Props" vs "State Reducers"](/blog/control-props-vs-state-reducers)

`useState` and `useReducer` fall into the second category here. So let's talk
about the trade-offs

(and no, it's not a
[trick question](https://twitter.com/ryanflorence/status/1234534306707456000)
ðŸ˜‚).

## Examples

I think the best way to discuss these trade-offs is through the lens of
examples. We'll look at two examples. One which suits `useState` better, and one
which suits `useReducer` better. This won't be enough to cover all of the
trade-offs, but hopefully can be a good starting point for us.

### Custom `useDarkMode` hook

I recently wrote this for my workshop projects
([for example](https://react-fundamentals.netlify.com)). It's pretty
interesting, so let's compare `useState` and `useReducer` implementations for
that:

#### `useState` implementation

I'll highlight the areas where we're interacting with the state:

```javascript {2-7,11,20}
function useDarkMode() {
  const preferDarkQuery = '(prefers-color-scheme: dark)'
  const [mode, setMode] = React.useState(
    () =>
      window.localStorage.getItem('colorMode') ||
      (window.matchMedia(preferDarkQuery).matches ? 'dark' : 'light'),
  )

  React.useEffect(() => {
    const mediaQuery = window.matchMedia(preferDarkQuery)
    const handleChange = () => setMode(mediaQuery.matches ? 'dark' : 'light')
    mediaQuery.addListener(handleChange)
    return () => mediaQuery.removeListener(handleChange)
  }, [])

  React.useEffect(() => {
    window.localStorage.setItem('colorMode', mode)
  }, [mode])

  return [mode, setMode]
}
```

Hopefully that makes sense. Basically we're saying, if the user's set their
preferences to dark mode, then we'll initialize our mode to `dark`, otherwise
we'll initialize to `light` and then return the `mode` and `setMode` and as the
mode changes (whether by calling `setMode` directly or as the user changes their
system preferences) we'll keep that value set in `localStorage` for future use.

#### `useReducer` implementation:

There are several ways you could write this with `useReducer`. I'll start out
with the typical way most people write reducers:

```javascript {3-17,21-27,30-35,40-43,56-59,61}
const preferDarkQuery = '(prefers-color-scheme: dark)'

function darkModeReducer(state, action) {
  switch (action.type) {
    case 'MEDIA_CHANGE': {
      return {...state, mode: action.mode}
    }
    case 'SET_MODE': {
      // make sure to spread that state just in case!
      return {...state, mode: action.mode}
    }
    default: {
      // helps us avoid typos!
      throw new Error(`Unhandled action type: ${action.type}`)
    }
  }
}

// use the init function to lazily initialize state so we don't read into
// localstorage or call matchMedia every render
function init() {
  return {
    mode:
      window.localStorage.getItem('colorMode') ||
      (window.matchMedia(preferDarkQuery).matches ? 'dark' : 'light'),
  }
}

function useDarkMode() {
  const [state, dispatch] = React.useReducer(
    darkModeReducer,
    {mode: 'light'},
    init,
  )
  const {mode} = state

  React.useEffect(() => {
    const mediaQuery = window.matchMedia(preferDarkQuery)
    const handleChange = () =>
      dispatch({
        type: 'MEDIA_CHANGE',
        mode: mediaQuery.matches ? 'dark' : 'light',
      })
    mediaQuery.addListener(handleChange)
    return () => mediaQuery.removeListener(handleChange)
  }, [])

  React.useEffect(() => {
    window.localStorage.setItem('colorMode', mode)
  }, [mode])

  // We like the API the way it is, so instead of returning the state object
  // and the dispatch function, we'll return the `mode` property and we'll
  // create a setMode helper (which we have to memoize in case someone wants
  // to use it in a dependency list):
  const setMode = React.useCallback(
    newMode => dispatch({type: 'SET_MODE', mode: newMode}),
    [],
  )

  return [mode, setMode]
}
```

Wow, I think we can both agree that the `useState` version was WAY simpler! But
wait! We can drastically simplify the `useReducer` version by going against the
"grain" and not writing your typical redux-style reducer. Let's try that:

```javascript {3-10,14,23}
function useDarkMode() {
  const preferDarkQuery = '(prefers-color-scheme: dark)'
  const [mode, setMode] = React.useReducer(
    (prevMode, nextMode) =>
      typeof nextMode === 'function' ? nextMode(prevMode) : nextMode,
    'light',
    () =>
      window.localStorage.getItem('colorMode') ||
      (window.matchMedia(preferDarkQuery).matches ? 'dark' : 'light'),
  )

  React.useEffect(() => {
    const mediaQuery = window.matchMedia(preferDarkQuery)
    const handleChange = () => setMode(mediaQuery.matches ? 'dark' : 'light')
    mediaQuery.addListener(handleChange)
    return () => mediaQuery.removeListener(handleChange)
  }, [])

  React.useEffect(() => {
    window.localStorage.setItem('colorMode', mode)
  }, [mode])

  return [mode, setMode]
}
```

That's a lot better than our other try with `useReducer`. But we basically
[implemented `useState` with `useReducer`](/blog/how-to-implement-usestate-with-usereducer).
And even then, it's still less clear than our `useState` version. So at the end
of the day, `useState` was a much better solution in this case.

**When it's just an independent element of state you're managing: `useState`**

### Custom `useUndo` hook

There's a great
[`useUndo` hook on GitHub](https://github.com/xxhomey19/use-undo). I took
inspiration from that for this example. Thank you
[Homer Chen](https://twitter.com/xxhomey19)!

#### `useState` implementation

```javascript
function useUndo(initialPresent) {
  const [past, setPast] = React.useState([])
  const [present, setPresent] = React.useState(initialPresent)
  const [future, setFuture] = React.useState([])

  const canUndo = past.length !== 0
  const canRedo = future.length !== 0

  const undo = React.useCallback(() => {
    if (!canUndo) return

    const previous = past[past.length - 1]
    const newPast = past.slice(0, past.length - 1)

    setPast(newPast)
    setPresent(previous)
    setFuture([present, ...future])
  }, [canUndo, future, past, present])

  const redo = React.useCallback(() => {
    if (!canRedo) return

    const next = future[0]
    const newFuture = future.slice(1)

    setPast([...past, present])
    setPresent(next)
    setFuture(newFuture)
  }, [canRedo, future, past, present])

  const set = React.useCallback(
    newPresent => {
      if (newPresent === present) {
        return
      }
      setPast([...past, present])
      setPresent(newPresent)
      setFuture([])
    },
    [past, present],
  )

  const reset = React.useCallback(newPresent => {
    setPast([])
    setPresent(newPresent)
    setFuture([])
  }, [])

  return [
    {past, present, future},
    {set, reset, undo, redo, canUndo, canRedo},
  ]
}
```

Looks pretty ok right? It probably is, but there's actually a situation where
this could be pretty buggy. But first, I want to address a common misconception
people have about calling multiple state updaters in sequence (like we're doing
in each of those functions).

Often people think this means that you'll trigger a re-render for each call (so,
they're suggesting that calling `reset` would trigger three rerenders). First,
remember to focus on
[Fixing the slow render before you fix the re-render](/blog/fix-the-slow-render-before-you-fix-the-re-render),
but secondly, remember that React has a batch system so if you were to call
`reset` from an event handler or in a `useEffect` callback, it would trigger
only one re-render.

That said, if we were to call `reset` in an async function (like after making an
HTTP request), then that _would_ result in three re-renders. However, in the
future with concurrent mode those will be batched as well. So my main concern
isn't the re-renders.

My concern is with the insidious stale closure bugs in our code! Can you spot
them? There are three! I'll give you a hint, there's one in each of `undo`,
`redo`, and `set`, but there's not one in `reset`.

Here's a contrived example that would reveal this bug:

```jsx
function Example() {
  const [state, {set}] = useUndo('first')

  React.useEffect(() => {
    set('second')
  }, [])

  React.useEffect(() => {
    set('third')
  }, [])

  return <pre>{JSON.stringify(state, null, 2)}</pre>
}
```

After `500ms`, the printed result here would be:

```json
{
  "past": ["first"],
  "present": "third",
  "future": []
}
```

It should be:

```json
{
  "past": ["first", "second"],
  "present": "third",
  "future": []
}
```

So what happened to `"second"` in our situation? Ah! Turns out we're missing our
dependency on `set` in the effect dependency array. Silly goose. Let's add
those:

```jsx {6,10}
function Example() {
  const [state, {set}] = useUndo('first')

  React.useEffect(() => {
    set('second')
  }, [set])

  React.useEffect(() => {
    set('third')
  }, [set])

  return <pre>{JSON.stringify(state, null, 2)}</pre>
}
```

Great, save, reload... Wait wut? Oh no! Here's what happened when I added those:

```json
{
  "past": [
    "first",
    "second",
    "third",
    "second",
    "third",
    "second",
    "third",
    "second",
    "third",
    "second",
    "third",
    "second",
    "third",
    "second",
    "third",
    "second",
    "third",
    "second",
    "third",
    "... this goes on forever..."
  ],
  "present": "third",
  "future": []
}
```

Alright, that's pretty ok I think. Let's check out the `useReducer` version:

#### `useReducer` implementation

```javascript
const UNDO = 'UNDO'
const REDO = 'REDO'
const SET = 'SET'
const RESET = 'RESET'

const initialState = {
  past: [],
  present: null,
  future: [],
}

function undoReducer(state, action) {
  const {past, present, future} = state

  const canUndo = state.past.length !== 0
  const canRedo = state.future.length !== 0

  switch (action.type) {
    case UNDO: {
      if (!canUndo) return
      const previous = past[past.length - 1]
      const newPast = past.slice(0, past.length - 1)

      return {
        past: newPast,
        present: previous,
        future: [present, ...future],
      }
    }

    case REDO: {
      if (!canRedo) return
      const next = future[0]
      const newFuture = future.slice(1)

      return {
        past: [...past, present],
        present: next,
        future: newFuture,
      }
    }

    case SET: {
      const {newPresent} = action

      if (newPresent === present) {
        return state
      }
      return {
        past: [...past, present],
        present: newPresent,
        future: [],
      }
    }

    case RESET: {
      const {newPresent} = action

      return {
        past: [],
        present: newPresent,
        future: [],
      }
    }
  }
}

function useUndo(initialPresent) {
  const [state, dispatch] = React.useReducer(undoReducer, {
    ...initialState,
    present: initialPresent,
  })

  const canUndo = state.past.length !== 0
  const canRedo = state.future.length !== 0
  const undo = React.useCallback(() => dispatch({type: UNDO}), [])
  const redo = React.useCallback(() => dispatch({type: REDO}), [])
  const set = React.useCallback(
    newPresent => dispatch({type: SET, newPresent}),
    [],
  )
  const reset = React.useCallback(
    newPresent => dispatch({type: RESET, newPresent}),
    [],
  )

  return [state, {set, reset, undo, redo, canUndo, canRedo}]
}
```

## One situation when `useReducer` is basically always better

**If your one element of your state relies on the value of another element of
your state, then it's almost always best to use `useReducer`**

For example, imagine you have a tic-tac-toe game you're writing. You have one
element of state called `squares` which is just an array of all the squares and
their value:

```
[
  ' ', 'X', 'O',
  'X', 'O', 'X',
  ' ', ' ', 'X'
]
```

and another called `xIsNext` which maintains the who's turn it is. When a user
clicks on a square, how does your code know whether the `squares` array should
update to `X` or `O`? It determines this based on the `xIsNext` state. Because
of this, it's easier to use a reducer because the reducer function can accept
all of the current state and use that current state (which includes `xIsNext`)
to determine the new state.

The benefits here are _mostly_ just code aesthetic, but if you start adding
async behavior here, then the case for `useReducer` is even more strong. With
our tic-tac-toe game, you can reference the current value of `xIsNext` in the
closure, but if you are updating the `squares` state asynchronously, then you
could be working with stale values of state which may or may not be what you
want. Using a reducer completely removes this potential issue though, which is
why I say it's basically always better to use a reducer if your state elements
depend on one another when they're updated.

Here's an example of tic-tac-toe with `useReducer`:

https://codesandbox.io/s/r1m6pz58mq

## Other considerations

Using previous values of state. When the current value of state A determines the
next value of state B.

[I asked about when people use each](https://twitter.com/kentcdodds/status/1234532781402640384)
and got a lot of answers where people stated what they consider to be a general
rule of thumb, but I disagree.

TODO: write more stuff here...

## Conclusion

So what's the answer? Really, it depends. `useState` is literally built on top
of `useReducer`. I don't think there are any relevant performance concerns
between the two so it's mostly a cosmetic/preferential decision.

While I conceptually like what Matt is encouraging, I think I may have a longer
threshold before I'll reach for `useReducer` to replace my `useState`. I also
really appreciate Matt for including this:

> they both have benefits and fallbacks that depend entirely upon their use

I think the best thing you can do to develop an intuition for when to reach for
one or the other is to feel the pain. Use them both and see how happy/sad they
make your life.

Good luck!
